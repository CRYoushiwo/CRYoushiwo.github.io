---
layout: page
permalink: /blogs/CourseRecording/2023/ComputerOrganization/Chapter6/index.html
title: ComputerOrganizationChapter6
---

# 中央处理器

## 重点题型

- 微命令的关系（相容/互斥）
- 根据题目要求的编码方式（水平/垂直），设计微指令的控制域 6.12
- 根据题目要求的编码方式（两地址/单地址/可变地址），设计微指令的地址域 6.12
- 控存容量的计算（一般放在设计之后，按照设计结果计算）6.12
- 依据假想机框图/运算器框图/指令的微操作流程示例，完成指定功能的指令的微操作流程，给出每个微操作对应的微命令 6.15，6.17
- 给出元件设计数据通路；给出数据通路，确定元件功能
- CPU性能测量  $T_{CPU}，CPI，MIPS，FLOPS$

## 概念与术语

- 微操作与微命令
    - 微操作：CPU的基本或原子操作
    - 微命令：控制微操作完成的控制信号
    - 微操作流程：微操作序列
- 微指令与微程序：
    - 微指令：一个节拍下的一个或多个微操作所需的控制信号组织成的指令
    - 微程序（固件）：微指令序列
- 微地址：控制存储器的地址
- 周期

| 指令周期 | CPU周期（机器周期） | 节拍周期 | 微指令周期 |
| --- | --- | --- | --- |
| 执行一条指令时间 | 指令周期的子周期 | 完成一个微操作时间 | 一条微指令执行时间（包括取出微指令） |
- 经典CPU周期分法：
    - 取址周期（公操作）
    - 中断周期（保护的是PC中的内容）
    - 执行周期
- 控制器：由控制单元，指令译码器，时序产生器组成
- **硬布线控制器：由控制单元，指令译码器，时序产生器组成**
    - 使用最少的元件，达到最快的操作速度
    - 控制单元：组合逻辑，输出微命令
        - 微命令表达式：
            
            $C_i = \sum(M_m\cdot T_n\cdot I_j\cdot F_k)$ 以二级时序为例
            
            - $M_m$：CPU周期
            - $T_n$：节拍
            - $I_J$：指令译码器的第j个输出
            - $F_K$：第k个CPU内部状态标志或CPU外部请求信号
- **微程序控制器：由控制存储器，微指令寄存器，微地址寄存器，时序逻辑组成**
    - 依据微程序顺序产生所需一条指令执行时所需的全部控制信号
- 主存与控存的区别：主存在CPU外，用于执行程序的。 控制存储器在CPU内，是CPU的组成部分，用于存储微程序的。

## CPU的功能与结构

- CPU基本概述
    - 主要负责获取程序中的每条指令，译码所获取的指令，针对指令指定的数据完成指定顺序操作。并确定指令的执行顺序（确定下条指令的地址）
    - 组成部分<控制器，运算器，通用寄存器组>
    - 主要寄存器
    - 数据通路
- 指令周期
    - 完成工作
        - 取下条指令
        - 取操作数
        - 执行指令
        - 检查中断，处理中断

## 时序系统

- 节拍周期
    - 由顺序脉冲发生器也称脉冲分配器或节拍脉冲发生器产生
- CPU周期
    - 定长CPU周期
    - 不定长CPU周期
- 指令周期
- 微操作流程（指令执行步骤）
    - 微操作描述
        - 取指周期（公操作）
        - 中断周期（不一定发生）
        - 执行周期
- 控制器
    - 组成
        - IR，PC，PSW
        - 时序部件
        - 控制单元CU
    - 设计控制器方法
        - 硬布线控制设计法
        - 微程序控制设计法

## 硬布线控制器设计

- 一级时序（产生节拍周期）
- 两级时序（产生节拍周期和CPU周期）
- 例题（x86控制单元为例）

![Untitled](%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8%20dbc3a49fe825411694c2d9d432e8ad01/Untitled.png)

- 优缺点【速度，修改不灵活，电路实现困难】

## 微程序控制器设计

- 组成
    - 控制存储器 $CM$（控存）
    - 微指令寄存器$\mu IR$，微地址寄存器$\mu AR$
    - 时序逻辑
- 工作过程：
    1. CPU执行某条指令，该指令的操作码和地址码经译码器生成该指令对应微程序的首地址，微程序启动
    2. 时序逻辑发出给控制存储器发出read信号，并从微地址寄存器中得到微指令存储地址，将微指令送入微指令寄存器
    3. 微指令寄存器产生控制信号和下一条微指令地址信息（微地址）
    4. 时序逻辑根据微地址信息和CPU内外状态，给微地址寄存器加载新的微地址
- 微指令设计
    - 微指令<地址域，控制域>
    - 地址域设计
        - 两地址格式（断定方式）
            
            
            | AC（=0or1） | 地址1 | 地址2 | 控制域 |
            | --- | --- | --- | --- |
        - 单地址格式（计数方式，增量方式）
            
            
            | AC（=0or1） | 地址 | 控制域 |
            | --- | --- | --- |
        - 可变格式
            1. 控制微指令
                
                
                | S（=0） | 控制域 |
                | --- | --- |
            2. 转移微指令
                
                
                | S（=1） | 分支控制 | 地址 |
                | --- | --- | --- |
        
        <aside>
        📢 两地址格式直接获取顺序地址和跳转地址
        单地址格式不增加微程序长度（微指令数量），用 $\mu PC$ 替换 $\mu AR$ ，减少了指令的长度
        可变格式仅有地址域或控制域中的一种，指令长度最短，但增加了微程序的长度
        
        </aside>
        
    - 控制域设计（编码）
        - 水平型微指令控制域编码
            
            直接表示法
            
            - 一个位 $\rightarrow$ 一个控制信号（$n\rightarrow n$）
            
            译码法
            
            - 一种编码 $\rightarrow$ 一个控制信号（$n\rightarrow 2^{n}$）
            
            字段译码法
            
            - 组内（互斥信号）垂直编码，+组间（相容信号）水平编码
            - 直接译码方式，间接译码方式
        - 垂直型微指令控制域编码
            
            
            | 微操作码 | 微操作数 |
            | --- | --- |
        
        <aside>
        ⚠️ 注意区分：垂直型微指令针对的是微操作，垂直编码针对的是控制信号
        
        </aside>
        
        - 优缺点【控制域的长度，并行能力，控制信号的译码电路】
    - 微程序设计
        - 微程序结构
            - 一条指令对应一段完整的微程序
            - 将微程序中的公共部分设计成微子程序进行公共调用
        - 编写微程序
    - 微程序控制器设计
    
    <aside>
    ⚠️ 综合性强，必定出一道大题
    
    - 指令分析（得到微操作与微命令序列）
    - 微命令分析（互斥与相容检查）
    - 微指令与控制器结构设计
        - 确定微指令地址域格式
        - 确定微指令控制域格式
    - 微程序与控制存储器设计
        
        $控制存储器容量＝微指令长度×(平均微程序长度(微指令数)/一条指令)×指令数$ 
        
        - 确定微程序结构
        - 确定微程序入口地址的生成方式
    - 微程序控制器实现
    </aside>
    

## CPU性能测量与提高

- CPU性能测量
    - $T_{CPU} = N*T_{CLK} = \frac{N}{f_{CLK}}$（s）CPU时间
    - $N = \sum{CPI_i\cdot I_i}$
    - $MIPS = \frac{I}{T_{CPU}*10^6} = \frac{f_{CLK}}{CPI*10^6}$
    - $FLOPS = \frac{M}{T_{CPU}}$
- 提高CPU速度的策略
    1. 采用更先进的硅加工制造技术
    2. 缩短指令执行路径长度
    3. 简化组织结构来缩短时钟周期
    4. 采用并行处理技术